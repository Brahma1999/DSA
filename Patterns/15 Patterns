15 most important patterns:
1.Prefix Sum:
Prefix Sum involves preprocessing an array to create a new array where each element at index i represents the sum of the array from the start up to i. This allows for efficient sum queries on subarrays.
Use this pattern when you need to perform multiple sum queries on a subarray or need to calculate cumulative sums.

A= [1,2,3,4,5,6]
SumArray=[1,3,6,10,15,21]
Problems:
Range Sum Query - Immutable (LeetCode #303)
Contiguous Array (LeetCode #525)
Subarray Sum Equals K (LeetCode #560)
Problems with this pattern:

https://leetcode.com/problems/subarray-sum-equals-k/
https://leetcode.com/problems/continuous-subarray-sum/
https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/
Problems sharing similarity in question framing:

https://leetcode.com/problems/minimum-size-subarray-sum/ (only +ve elements): different from above pattern problems, where we are maximising the subArray size so repetitions on cumulativeSums occur, whereas in this problem we are minimizing the size of candidate so sliding becomes handy.
https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/ (contains -ve elements): uses monotonic deque


2. Two Pointers
The Two Pointers pattern involves using two pointers to iterate through an array or list, often used to find pairs or elements that meet specific criteria.
Use this pattern when dealing with sorted arrays or lists where you need to find pairs that satisfy a specific condition.

3. Sliding Window
4. Fast & Slow Pointers
5. LinkedList In-place Reversal
6. Monotonic Stack
7. Top ‘K’ Elements
8. Overlapping Intervals
9. Modified Binary Search
10. Binary Tree Traversal
11. Depth-First Search (DFS)
12. Breadth-First Search (BFS)
13. Matrix Traversal
14. Backtracking
15. Dynamic Programming Patterns

Helpful ->  https://blog.algomaster.io/p/15-leetcode-patterns
